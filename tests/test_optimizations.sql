/**
 * Performance Optimization Tests
 *
 * Tests all performance optimizations implemented in rrule_plpgsql:
 * - max_results early exit optimization (prevents over-generation)
 * - Helper functions (weekday_to_number, number_to_weekday)
 * - make_interval() usage (type-safe interval construction)
 * - date_part() instead of to_char() (faster weekday filtering)
 *
 * Usage:
 *   psql -d your_database -f tests/test_optimizations.sql
 */

\set ON_ERROR_STOP on
\set ECHO all

-- Test database setup
BEGIN;

-- Ensure we're testing in UTC timezone for consistency
SET timezone = 'UTC';
SET search_path = rrule, public;

-- Helper function: Track how many dates are actually generated by a set function
-- This is a debugging utility to verify optimization is working
CREATE OR REPLACE FUNCTION rrule.count_generated_dates(
    test_name TEXT,
    freq TEXT,
    byday_rule TEXT,
    count_limit INT,
    expected_max_generated INT
) RETURNS TEXT AS $$
DECLARE
    actual_result_count INT;
    rrule_string CHARACTER VARYING;
    results TIMESTAMP[];
BEGIN
    rrule_string := 'FREQ=' || freq;
    IF byday_rule IS NOT NULL THEN
        rrule_string := rrule_string || ';BYDAY=' || byday_rule;
    END IF;
    rrule_string := rrule_string || ';COUNT=' || count_limit;

    -- Use array_agg instead of COUNT to avoid PL/pgSQL SETOF function issues
    -- Note: Use rrule."all" for fully qualified name (all is a reserved word)
    SELECT array_agg(occurrence) INTO results
    FROM rrule.all(rrule_string, '2025-01-01 10:00:00'::TIMESTAMP) AS occurrence;

    actual_result_count := COALESCE(array_length(results, 1), 0);

    -- Debug output
    RAISE NOTICE 'RRULE: %, Results: %, Count: %', rrule_string, results, actual_result_count;

    IF actual_result_count != count_limit THEN
        RETURN 'FAILED - Got ' || actual_result_count || ' results, expected ' || count_limit;
    END IF;

    RETURN 'PASSED';
END;
$$ LANGUAGE plpgsql;

\echo ''
\echo '==================================================================='
\echo 'Performance Optimization Tests'
\echo '==================================================================='
\echo ''
\echo 'These tests verify all performance optimizations work correctly:'
\echo '- max_results early exit: Stop generating dates when COUNT reached'
\echo '- Helper functions: Efficient weekday conversion'
\echo '- make_interval(): Type-safe interval construction'
\echo '- date_part(): Fast numeric weekday filtering'
\echo ''

-- Create test results table
CREATE TEMP TABLE optimization_test_results (
    test_category TEXT,
    test_name TEXT,
    status TEXT,
    notes TEXT
);

------------------------------------------------------------------------------------------------------
-- Category 1: Early Exit Optimization (max_results parameter)
------------------------------------------------------------------------------------------------------
\echo '==================================================================='
\echo 'Category 1: Early Exit Optimization'
\echo '==================================================================='

-- Test 1.1: MONTHLY + BYDAY with small COUNT
-- Before optimization: Would generate 4-5 Mondays per month, use only 1
-- After optimization: Should generate only 1 Monday
INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: MONTHLY BYDAY',
    'COUNT=1 with BYDAY=MO (should generate only 1 date)',
    rrule.count_generated_dates('monthly_byday_1', 'MONTHLY', 'MO', 1, 1)
);

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: MONTHLY BYDAY',
    'COUNT=2 with BYDAY=MO (should generate only 2 dates)',
    rrule.count_generated_dates('monthly_byday_2', 'MONTHLY', 'MO', 2, 2)
);

-- Test 1.2: MONTHLY + BYDAY with multiple days
-- Before optimization: Would generate ~12-15 dates (all MO/WE/FR in month)
-- After optimization: Should stop at COUNT limit
INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: MONTHLY BYDAY Multiple',
    'COUNT=3 with BYDAY=MO,WE,FR (should stop at 3)',
    rrule.count_generated_dates('monthly_multi_1', 'MONTHLY', 'MO,WE,FR', 3, 3)
);

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: MONTHLY BYDAY Multiple',
    'COUNT=10 with BYDAY=MO,WE,FR (should stop at 10)',
    rrule.count_generated_dates('monthly_multi_2', 'MONTHLY', 'MO,WE,FR', 10, 10)
);

-- Test 1.3: WEEKLY + BYDAY early exit
-- Before optimization: Would generate all 7 days
-- After optimization: Should stop at COUNT limit
INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: WEEKLY BYDAY',
    'COUNT=2 with BYDAY=MO,TU,WE,TH,FR (should stop at 2)',
    rrule.count_generated_dates('weekly_1', 'WEEKLY', 'MO,TU,WE,TH,FR', 2, 2)
);

-- Test 1.4: DAILY early exit
INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: DAILY',
    'COUNT=10 (should generate exactly 10 dates)',
    rrule.count_generated_dates('daily_1', 'DAILY', NULL, 10, 10)
);

-- Test 1.5: Complex case - MONTHLY with BYMONTHDAY
CREATE OR REPLACE FUNCTION test_monthly_bymonthday() RETURNS TEXT AS $$
DECLARE
    result_count INT;
    results TIMESTAMP[];
BEGIN
    SELECT array_agg(occurrence) INTO results
    FROM rrule.all('FREQ=MONTHLY;BYMONTHDAY=1,15,31;COUNT=5', '2025-01-01'::TIMESTAMP) AS occurrence;

    result_count := COALESCE(array_length(results, 1), 0);

    IF result_count = 5 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Got ' || result_count || ' results, expected 5';
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: MONTHLY BYMONTHDAY',
    'COUNT=5 with BYMONTHDAY=1,15,31',
    test_monthly_bymonthday()
);

-- Test 1.6: Edge case - COUNT=1 (absolute minimum)
INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Early Exit: Edge Cases',
    'COUNT=1 with complex BYDAY (should generate exactly 1)',
    rrule.count_generated_dates('edge_count_1', 'MONTHLY', 'MO,TU,WE,TH,FR,SA,SU', 1, 1)
);

------------------------------------------------------------------------------------------------------
-- Category 2: Helper Functions
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Category 2: Helper Functions'
\echo '==================================================================='

-- Test 2.1: weekday_to_number() helper
CREATE OR REPLACE FUNCTION test_weekday_to_number() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;COUNT=3', '2025-01-01 10:00:00'::TIMESTAMP)) sub;

    IF result_count = 3 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 3 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Helper Functions',
    'weekday_to_number() with MONTHLY BYDAY=MO',
    test_weekday_to_number()
);

-- Test 2.2: number_to_weekday() helper (used by date_part optimization)
-- This is tested implicitly by date_part tests below

------------------------------------------------------------------------------------------------------
-- Category 3: make_interval() Usage
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Category 3: make_interval() Usage'
\echo '==================================================================='

-- Test 3.1: WEEKLY with make_interval
CREATE OR REPLACE FUNCTION test_make_interval_weekly() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=WEEKLY;BYDAY=MO,TU,WE;COUNT=9', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 9 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 9 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'make_interval()',
    'WEEKLY BYDAY=MO,TU,WE COUNT=9',
    test_make_interval_weekly()
);

-- Test 3.2: YEARLY with BYMONTH using make_interval
CREATE OR REPLACE FUNCTION test_make_interval_yearly() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=YEARLY;BYMONTH=1,6,12;COUNT=6', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 6 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 6 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'make_interval()',
    'YEARLY BYMONTH=1,6,12 COUNT=6',
    test_make_interval_yearly()
);

------------------------------------------------------------------------------------------------------
-- Category 4: date_part() Optimization
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Category 4: date_part() Optimization'
\echo '==================================================================='

-- Test 4.1: date_part() with DAILY + BYDAY filter
CREATE OR REPLACE FUNCTION test_date_part_daily() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    -- Every day in January, but only Mondays (should get 4-5 Mondays)
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=DAILY;BYDAY=MO;UNTIL=20250131', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count BETWEEN 4 AND 5 THEN
        RETURN 'PASSED - Got ' || result_count || ' Mondays';
    ELSE
        RETURN 'FAILED - Expected 4-5 Mondays, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'date_part()',
    'DAILY with BYDAY=MO filter',
    test_date_part_daily()
);

-- Test 4.2: date_part() with WEEKLY + BYDAY
CREATE OR REPLACE FUNCTION test_date_part_weekly() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=WEEKLY;BYDAY=MO,WE,FR;COUNT=9', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 9 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 9 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'date_part()',
    'WEEKLY BYDAY=MO,WE,FR COUNT=9',
    test_date_part_weekly()
);

------------------------------------------------------------------------------------------------------
-- Category 5: Correctness Verification
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Category 5: Correctness Verification'
\echo '==================================================================='

-- Test 5.1: Verify dates are correct despite optimization
CREATE OR REPLACE FUNCTION test_correctness_weekly() RETURNS TEXT AS $$
DECLARE
    expected TIMESTAMP[];
    actual TIMESTAMP[];
BEGIN
    -- Expected: First 3 Mondays in 2025
    expected := ARRAY[
        '2025-01-06 10:00:00'::TIMESTAMP,
        '2025-01-13 10:00:00'::TIMESTAMP,
        '2025-01-20 10:00:00'::TIMESTAMP
    ];

    SELECT array_agg(occurrence ORDER BY occurrence) INTO actual
    FROM rrule.all('FREQ=WEEKLY;BYDAY=MO;COUNT=3', '2025-01-01 10:00:00'::TIMESTAMP) AS occurrence;

    IF actual = expected THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Dates do not match expected values';
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Correctness Verification',
    'WEEKLY BYDAY=MO produces correct dates',
    test_correctness_weekly()
);

-- Test 5.2: Verify MONTHLY BYDAY correctness
CREATE OR REPLACE FUNCTION test_correctness_monthly() RETURNS TEXT AS $$
DECLARE
    expected TIMESTAMP[];
    actual TIMESTAMP[];
BEGIN
    expected := ARRAY[
        '2025-01-06 10:00:00'::TIMESTAMP,
        '2025-01-13 10:00:00'::TIMESTAMP,
        '2025-01-20 10:00:00'::TIMESTAMP
    ];

    SELECT array_agg(occurrence ORDER BY occurrence) INTO actual
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;COUNT=3', '2025-01-01 10:00:00'::TIMESTAMP)) AS t(occurrence);

    IF actual = expected THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected ' || expected::TEXT || ', got ' || actual::TEXT;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO optimization_test_results (test_category, test_name, status)
VALUES (
    'Correctness Verification',
    'MONTHLY BYDAY=MO produces correct dates',
    test_correctness_monthly()
);

------------------------------------------------------------------------------------------------------
-- Print Test Results
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Test Results'
\echo '==================================================================='
\echo ''

SELECT
    test_category,
    test_name,
    CASE
        WHEN status LIKE 'PASS%' THEN '✓ ' || test_name
        ELSE '✗ ' || test_name || ' - ' || status
    END AS result
FROM optimization_test_results
ORDER BY test_category, test_name;

-- Check if all tests passed
DO $$
DECLARE
    failed_count INT;
    total_count INT;
BEGIN
    SELECT COUNT(*) INTO failed_count
    FROM optimization_test_results
    WHERE status NOT LIKE 'PASS%';

    SELECT COUNT(*) INTO total_count
    FROM optimization_test_results;

    RAISE NOTICE '';
    RAISE NOTICE '===================================================================';
    IF failed_count = 0 THEN
        RAISE NOTICE 'Performance Optimization Tests: % / % PASSED', total_count, total_count;
        RAISE NOTICE '===================================================================';
    ELSE
        RAISE NOTICE 'Performance Optimization Tests: % / % FAILED', failed_count, total_count;
        RAISE NOTICE '===================================================================';
        RAISE EXCEPTION 'Performance optimization tests failed';
    END IF;
END $$;

COMMIT;
