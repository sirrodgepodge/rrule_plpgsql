/**
 * BYSETPOS Filtering Tests
 *
 * Tests BYSETPOS parameter functionality and array-based optimization.
 * BYSETPOS selects specific occurrences from the set generated by other rules.
 *
 * RFC 5545 Section 3.3.10:
 * "BYSETPOS operates on a SETOF dates, selecting a subset of those dates.
 *  Positive values select from the beginning, negative from the end."
 *
 * Implementation:
 * - Uses array-based filtering for O(1) position access
 * - Supports positive indices (1, 2, 3...) for first, second, third...
 * - Supports negative indices (-1, -2, -3...) for last, second-to-last...
 * - Gracefully handles out-of-range positions (skips)
 *
 * Usage:
 *   psql -d your_database -f tests/test_bysetpos.sql
 */

\set ON_ERROR_STOP on
\set ECHO all

-- Test database setup
BEGIN;

SET timezone = 'UTC';
SET search_path = rrule, public;

\echo ''
\echo '==================================================================='
\echo 'BYSETPOS Filtering Tests'
\echo '==================================================================='
\echo ''
\echo 'Tests array-based BYSETPOS filtering with positive, negative,'
\echo 'and multiple position indices.'
\echo ''

-- Create test results table
CREATE TEMP TABLE bysetpos_test_results (
    test_category TEXT,
    test_name TEXT,
    status TEXT
);

------------------------------------------------------------------------------------------------------
-- Category 1: Single Position Selection
------------------------------------------------------------------------------------------------------
\echo '==================================================================='
\echo 'Category 1: Single Position Selection'
\echo '==================================================================='

-- Test 1.1: First position (BYSETPOS=1)
-- Use case: First Monday of each month
CREATE OR REPLACE FUNCTION test_bysetpos_first() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=1;COUNT=3', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 3 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 3 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Single Position',
    'BYSETPOS=1 (first Monday of each month)',
    test_bysetpos_first()
);

-- Test 1.2: Second position (BYSETPOS=2)
CREATE OR REPLACE FUNCTION test_bysetpos_second() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=2;COUNT=3', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 3 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 3 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Single Position',
    'BYSETPOS=2 (second Monday of each month)',
    test_bysetpos_second()
);

-- Test 1.3: Last position (BYSETPOS=-1)
-- Use case: Last Monday of each month
CREATE OR REPLACE FUNCTION test_bysetpos_last() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=-1;COUNT=3', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 3 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 3 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Single Position',
    'BYSETPOS=-1 (last Monday of each month)',
    test_bysetpos_last()
);

-- Test 1.4: Second-to-last position (BYSETPOS=-2)
CREATE OR REPLACE FUNCTION test_bysetpos_second_last() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=-2;COUNT=3', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 3 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 3 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Single Position',
    'BYSETPOS=-2 (second-to-last Monday)',
    test_bysetpos_second_last()
);

------------------------------------------------------------------------------------------------------
-- Category 2: Multiple Position Selection
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Category 2: Multiple Position Selection'
\echo '==================================================================='

-- Test 2.1: First and third (BYSETPOS=1,3)
CREATE OR REPLACE FUNCTION test_bysetpos_multiple() RETURNS TEXT AS $$
DECLARE
    result_count INT;
    expected TIMESTAMP[];
    actual TIMESTAMP[];
BEGIN
    -- Expected: 1st Mon (Jan 6), 3rd Mon (Jan 20), 1st Mon (Feb 3)
    expected := ARRAY[
        '2025-01-06 00:00:00'::TIMESTAMP,
        '2025-01-20 00:00:00'::TIMESTAMP,
        '2025-02-03 00:00:00'::TIMESTAMP
    ];

    SELECT array_agg(occurrence ORDER BY occurrence) INTO actual
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=1,3;COUNT=3', '2025-01-01'::TIMESTAMP)) AS t(occurrence);

    IF actual = expected THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected ' || expected::TEXT || ', got ' || actual::TEXT;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Multiple Positions',
    'BYSETPOS=1,3 (first and third Monday)',
    test_bysetpos_multiple()
);

-- Test 2.2: First and last (BYSETPOS=1,-1)
CREATE OR REPLACE FUNCTION test_bysetpos_first_last() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=1,-1;COUNT=4', '2025-01-01'::TIMESTAMP)) sub;

    -- Should get 2 per month (first and last Monday), COUNT=4 means 4 total
    IF result_count = 4 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 4 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Multiple Positions',
    'BYSETPOS=1,-1 (first and last Monday)',
    test_bysetpos_first_last()
);

-- Test 2.3: Multiple weekdays with multiple positions
CREATE OR REPLACE FUNCTION test_bysetpos_multi_weekday() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    -- Weekly, all weekdays (MO-FR), get only first 2 each week
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR;BYSETPOS=1,2;COUNT=3', '2025-01-06'::TIMESTAMP)) sub;

    -- Should get 2 per week (first 2 weekdays), stop at COUNT=3 means 3 total
    IF result_count = 3 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 3 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Multiple Positions',
    'BYSETPOS=1,2 with BYDAY=MO,TU,WE,TH,FR',
    test_bysetpos_multi_weekday()
);

------------------------------------------------------------------------------------------------------
-- Category 3: Edge Cases
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Category 3: Edge Cases'
\echo '==================================================================='

-- Test 3.1: Out of range positive (BYSETPOS=6)
-- January has 4-5 Mondays, asking for 6th should skip
CREATE OR REPLACE FUNCTION test_bysetpos_out_of_range() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=6;COUNT=5', '2025-01-01'::TIMESTAMP)) sub;

    -- Should return 0 because no month has 6 Mondays
    IF result_count = 0 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 0 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Edge Cases',
    'BYSETPOS=6 out of range (should skip gracefully)',
    test_bysetpos_out_of_range()
);

-- Test 3.2: Out of range negative (BYSETPOS=-10)
CREATE OR REPLACE FUNCTION test_bysetpos_out_of_range_negative() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=-10;COUNT=5', '2025-01-01'::TIMESTAMP)) sub;

    -- Should return 0 because no month has 10 Mondays
    IF result_count = 0 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 0 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Edge Cases',
    'BYSETPOS=-10 out of range negative (should skip)',
    test_bysetpos_out_of_range_negative()
);

-- Test 3.3: BYSETPOS with COUNT=1 (minimum)
CREATE OR REPLACE FUNCTION test_bysetpos_count_one() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=1;COUNT=1', '2025-01-01'::TIMESTAMP)) sub;

    IF result_count = 1 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 1 result, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Edge Cases',
    'BYSETPOS=1 with COUNT=1 (minimum)',
    test_bysetpos_count_one()
);

-- Test 3.4: Mixed positive and negative with gaps (BYSETPOS=1,3,-2,-1)
CREATE OR REPLACE FUNCTION test_bysetpos_mixed_complex() RETURNS TEXT AS $$
DECLARE
    result_count INT;
BEGIN
    SELECT COUNT(*) INTO result_count
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=1,3,-2,-1;COUNT=8', '2025-01-01'::TIMESTAMP)) sub;

    -- Should get 4 per month (1st, 3rd, 2nd-to-last, last), COUNT=8 means 8 total
    IF result_count = 8 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected 8 results, got ' || result_count;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Edge Cases',
    'BYSETPOS=1,3,-2,-1 (complex mixed)',
    test_bysetpos_mixed_complex()
);

------------------------------------------------------------------------------------------------------
-- Category 4: Correctness Verification
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Category 4: Correctness Verification'
\echo '==================================================================='

-- Test 4.1: Verify first Monday dates are correct
CREATE OR REPLACE FUNCTION test_bysetpos_first_monday_dates() RETURNS TEXT AS $$
DECLARE
    expected TIMESTAMP[];
    actual TIMESTAMP[];
BEGIN
    -- First Monday of Jan, Feb, Mar 2025
    expected := ARRAY[
        '2025-01-06 00:00:00'::TIMESTAMP,
        '2025-02-03 00:00:00'::TIMESTAMP,
        '2025-03-03 00:00:00'::TIMESTAMP
    ];

    SELECT array_agg(occurrence ORDER BY occurrence) INTO actual
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=1;COUNT=3', '2025-01-01'::TIMESTAMP)) AS t(occurrence);

    IF actual = expected THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected ' || expected::TEXT || ', got ' || actual::TEXT;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Correctness Verification',
    'First Monday dates are correct',
    test_bysetpos_first_monday_dates()
);

-- Test 4.2: Verify last Monday dates are correct
CREATE OR REPLACE FUNCTION test_bysetpos_last_monday_dates() RETURNS TEXT AS $$
DECLARE
    expected TIMESTAMP[];
    actual TIMESTAMP[];
BEGIN
    -- Last Monday of Jan, Feb, Mar 2025
    expected := ARRAY[
        '2025-01-27 00:00:00'::TIMESTAMP,
        '2025-02-24 00:00:00'::TIMESTAMP,
        '2025-03-31 00:00:00'::TIMESTAMP
    ];

    SELECT array_agg(occurrence ORDER BY occurrence) INTO actual
    FROM (SELECT * FROM rrule.all('FREQ=MONTHLY;BYDAY=MO;BYSETPOS=-1;COUNT=3', '2025-01-01'::TIMESTAMP)) AS t(occurrence);

    IF actual = expected THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED - Expected ' || expected::TEXT || ', got ' || actual::TEXT;
    END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO bysetpos_test_results (test_category, test_name, status)
VALUES (
    'Correctness Verification',
    'Last Monday dates are correct',
    test_bysetpos_last_monday_dates()
);

------------------------------------------------------------------------------------------------------
-- Print Test Results
------------------------------------------------------------------------------------------------------
\echo ''
\echo '==================================================================='
\echo 'Test Results'
\echo '==================================================================='
\echo ''

SELECT
    test_category,
    test_name,
    CASE
        WHEN status LIKE 'PASS%' THEN '✓ ' || test_name
        ELSE '✗ ' || test_name || ' - ' || status
    END AS result
FROM bysetpos_test_results
ORDER BY test_category, test_name;

-- Check if all tests passed
DO $$
DECLARE
    failed_count INT;
    total_count INT;
BEGIN
    SELECT COUNT(*) INTO failed_count
    FROM bysetpos_test_results
    WHERE status NOT LIKE 'PASS%';

    SELECT COUNT(*) INTO total_count
    FROM bysetpos_test_results;

    RAISE NOTICE '';
    RAISE NOTICE '===================================================================';
    IF failed_count = 0 THEN
        RAISE NOTICE 'BYSETPOS Filtering Tests: % / % PASSED', total_count, total_count;
        RAISE NOTICE '===================================================================';
    ELSE
        RAISE NOTICE 'BYSETPOS Filtering Tests: % / % FAILED', failed_count, total_count;
        RAISE NOTICE '===================================================================';
        RAISE EXCEPTION 'BYSETPOS filtering tests failed';
    END IF;
END $$;

COMMIT;
